---
layout: post
title: 面试被问到的问题
categories: Interview
description: 将面试过程中遇到的问题记录下来
keywords: Interview, 面试
---



## 基本概念

1. java 接口的修饰符：

   - 接口的方法默认是 public abstract
   - 接口的属性默认是 public static final 常量，且必须赋初值

   **分析：**

   1. 接口用于描述系统对外提供的所有服务,因此接口中的成员常量和方法都必须是公开(public)类型的,确保外部使用者能访问它们；

   2. 接口仅仅描述系统能做什么,但不指明如何去做,所以接口中的方法都是抽象(abstract)方法

   3. 接口不涉及和任何具体实例相关的细节,因此接口没有构造方法,不能被实例化,没有实例变量，只有静态（static）变量

   4. 接口的中的变量是所有实现类共有的，既然共有，肯定是不变的东西，因为变化的东西也不能够算共有。所以变量是不可变(final)类型，也就是常量了

      ​

2. ````java
   System.out.println("5" + 2)
   ````

   输出：52

   任何和字符串进行+运算的结果都相当于字符串的连接。

   ​

3. IO 流

   Java的IO操作中有面向 `字节(Byte)` 和面向 `字符(Character)` 两种方式。

   - 面向字节的操作为以8位为单位对二进制的数据进行操作，对数据不进行转换，这些类都是`InputStream` 和`OutputStream` 的子类。


   - 面向字符的操作为以字符为单位对数据进行操作，在读的时候将二进制数据转为字符，在写的时候将字符转为二进制数据，这些类都是 `Reader` 和 `Writer` 的子类。

     ​

   **总结：**以InputStream（输入）/OutputStream（输出）为后缀的是字节流；
   以Reader（输入）/Writer（输出）为后缀的是字符流。

   ![](https://github.com/zhangjinmiao/zhangjinmiao.github.io/raw/master/assets/images/2018/interview/io.jpg)

   ​

4. ArrayList 和 LinkedList 区别

   1. ArrayList是实现了基于`动态数组`的数据结构，LinkedList基于`链表`的数据结构。
   2. 对于随机访问 get 和 set，ArrayList 优于LinkedList，因为LinkedList 要移动指针。
   3. 对于新增和删除操作 add 和 remove，LinedList 比较占优势，因为 ArrayList 要移动数据。

   ​

5. volatile 和 synchronized 的区别

   - volatile 轻量级，只能修饰变量。synchronized 重量级，还可修饰方法


   - volatile 只能保证数据的`可见性`，不能用来同步，因为多个线程并发访问volatile修饰的变量不会阻塞。
   - 仅仅使用 volatile 并`不能保证线程安全性`。而 synchronized 则`可实现线程的安全性`。

   ​

6. 异常

   Java标准库内建了一些通用的异常，这些类以`Throwable` 为顶层父类。

   `Throwable` 又派生出` Error` 类和` Exception` 类。

   - 错误：`Error` 类以及他的子类的实例，代表了JVM本身的错误。错误不能被程序员通过代码处理，Error 很少出现。因此，程序员应该关注Exception为父类的分支下的各种异常类。
   - 异常：`Exception` 以及他的子类，代表程序运行时发送的各种不期望发生的事件。可以被Java异常处理机制使用，是异常处理的核心。

   ![](https://github.com/zhangjinmiao/zhangjinmiao.github.io/raw/master/assets/images/2018/interview/throwable.jpg)

   ​

   总体上根据Javac对异常的处理要求，将异常类分为2类。

   - **非检查异常**（unckecked exception）：Error 和 RuntimeException 以及他们的子类。javac 在编译时，不会提示和发现这样的异常，不要求在程序处理这些异常。所以如果愿意，我们可以编写代码处理（使用try…catch…finally）这样的异常，也可以不处理。

     > 对于这些异常，我们应该修正代码，而不是去通过异常处理器处理 。这样的异常发生的原因多半是代码写的有问题。如除0错误ArithmeticException，错误的强制类型转换错误ClassCastException，数组索引越界ArrayIndexOutOfBoundsException，使用了空对象NullPointerException等等。

   - **检查异常**（checked exception）：除了Error 和 RuntimeException的其它异常。javac强制要求程序员为这样的异常做预备处理工作（使用try…catch…finally或者throws）。在方法中要么用try-catch语句捕获它并处理，要么用throws子句声明抛出它，否则编译不会通过。

     > 这样的异常一般是由程序的运行环境导致的。因为程序可能被运行在各种未知的环境下，而程序员无法干预用户如何使用他编写的程序，于是程序员就应该为这样的异常时刻准备着。如SQLException , IOException,ClassNotFoundException 等。

     ![](https://github.com/zhangjinmiao/zhangjinmiao.github.io/raw/master/assets/images/2018/interview/e1.jpg)

     ![](https://github.com/zhangjinmiao/zhangjinmiao.github.io/raw/master/assets/images/2018/interview/e2.jpg)

   参考：http://www.importnew.com/26613.html

   ​

7. AIO 和 NIO 有什么区别

   ​

8. ​

   ​



## 写出运行结果

1. 运行结果：

   pong

   ping

   ````java
   public static void main(String[] args) {
     Thread t = new Thread(){
       @Override
       public void run() {
         pong();
       }
     };
     t.run();
     System.out.println("ping");
   }

   static void pong(){
     System.out.println("pong");
   }
   ````

   这道题是考了Thread 的 start() 和 run() 方法的区别：

   > 1.  start():
   >
   >    - 使该线程开始执行；Java 虚拟机调用该线程的 `run` 方法。
   >
   >
   >    - 结果是两个线程并发地运行；当前线程（从调用返回给 `start` 方法）和另一个线程（执行其 `run` 方法，本例中为 main 方法）。
   >
   >
   >    - 多次启动一个线程是非法的。特别是当线程已经结束执行后，不能再重新启动。
   >
   >    用start方法来启动线程，真正实现了多线程运行，这时无需等待run方法体代码执行完毕而直接继续执行下面的代码。通过调用Thread类的 start()方法来启动一个线程，这时此线程处于就绪（可运行）状态，并没有运行，一旦得到cpu时间片，就开始执行run()方法，这里方法 run()称为线程体，它包含了要执行的这个线程的内容，Run方法运行结束，此线程随即终止。
   >
   >    通过调用`run()` 方法才是正确的使用线程的方式。
   >
   > 2. run()
   >
   >    - 如果该线程是使用独立的 `Runnable` 运行对象构造的，则调用该 `Runnable` 对象的 `run` 方法；否则，该方法不执行任何操作并返回.
   >    - `Thread` 的子类应该重写该方法。
   >
   >    run()方法只是类的一个普通方法而已，如果直接调用Run方法，程序中依然只有主线程这一个线程，其程序执行路径还是只有一条，还是要顺序执行，还是要等待run方法体执行完毕后才可继续执行下面的代码，这样就没有达到写线程的目的。

   **总结：**

   start() 方法的作用是启动一个新线程，新线程会执行相应的run()方法，start()不能被重复调用。

   而run()方法则只是普通的方法调用，在调用线程中顺序运行而已。

   ​

   **JDK1.8.0_152**中关于`start()` 和` run()` 的源码

   ````java
   public synchronized void start() {
           /**
            * This method is not invoked for the main method thread or "system"
            * group threads created/set up by the VM. Any new functionality added
            * to this method in the future may have to also be added to the VM.
            *
            * A zero status value corresponds to state "NEW".
            */
     		 // 如果线程不是"就绪状态"，则抛出异常！  
           if (threadStatus != 0)
               throw new IllegalThreadStateException();

           /* Notify the group that this thread is about to be started
            * so that it can be added to the group's list of threads
            * and the group's unstarted count can be decremented. */
      		// 将线程添加到ThreadGroup中  
           group.add(this);

           boolean started = false;
           try {
              // 通过start0()启动线程,新线程会调用run()方法  
               start0();
              // 设置started标记=true  
               started = true;
           } finally {
               try {
                   if (!started) {
                       group.threadStartFailed(this);
                   }
               } catch (Throwable ignore) {
                   /* do nothing. If start0 threw a Throwable then
                     it will be passed up the call stack */
               }
           }
       }
   private native void start0();
   ````

   ````java
   /**
        * If this thread was constructed using a separate
        * <code>Runnable</code> run object, then that
        * <code>Runnable</code> object's <code>run</code> method is called;
        * otherwise, this method does nothing and returns.
        * <p>
        * Subclasses of <code>Thread</code> should override this method.
        *
        * @see     #start()
        * @see     #stop()
        * @see     #Thread(ThreadGroup, Runnable, String)
        */
       @Override
       public void run() {
           if (target != null) {
               target.run();
           }
       }
   ````

   ​

2. 输出：

   >static A
   >static B
   >I'm A class
   >HelloA
   >I'm B class
   >HelloB

   ````java
   public class HelloA {
       public HelloA(){
           System.out.println("HelloA");
       }
       {
           System.out.println("I'm A class");
       }
       static {
           System.out.println("static A");
       }
   }

   public class HelloB extends HelloA {
       public HelloB(){
           System.out.println("HelloB");
       }
       {
           System.out.println("I'm B class");
       }
       static {
           System.out.println("static B");
       }

       public static void main(String[] args) {
           new HelloB();
       }
   }
   ````

   **分析：**

   - 首先去看父类里面有没有 `静态代码块`，如果有，它先去执行父类里面静态代码块里面的内容，当父类的静态代码块里面的内容执行完毕之后， 接着去执行子类(自己这个类)里面的 `静态代码块`，
   - 当子类的静态代码块执行完毕之后，它接着又去看父类有没有 `非静态代码块`，如果有就执行父类的非静态代码块，父类的非静态代码块执行完毕，接着执行父类的 `构造方法`，
   - 父类的构造方法执行完毕之后，它接着去看子类有没有非静态代码块，如果有就执行子类的非静态代 码块，子类的非静态代码块执行完毕再去执行子类的构造方法

   总结：

   `父类静态代码块`——> `子类静态代码块`——>`父类非静态代码块，构造方法`——>`子类非静态代码块，构造方法`

   这个就是一个对象的初始化顺序。

   ![](https://github.com/zhangjinmiao/zhangjinmiao.github.io/raw/master/assets/images/2018/interview/jvm.png)

   - 静态代码优先于非静态的代码,是因为被 `static` 修饰的成员都是类成员,会随着 JVM 加载类的时候加载而执行,而没有被 `static` 修饰的成员也被称为实例成员,需要创建对象才会随之加载到堆内存。所以静态的会优先非静态的。 


   - 执行构造器(构造方法)的时候,在执行方法体之前存在隐式三步: 1,super语句,2,初始化非静态变量; 3,构造代码块。

3. ​



## 并发相关

1. 什么是 CopyOnWrite 容器

   ​

2. ​





## 数据库

1. 事务隔离级别有哪些，区别

   ​

2. ​



## Spring

1. spring 事务的传播行为，区别

   ​

2. ​



## JVM

1. 对象在 JVM 有哪些状态

   ​

2. 常用垃圾收集器

   ​

3. 遇到 OOM 如何处理

   ​

4. 如何减少上下文切换



## 编程

1. 二叉树迭代：先根，中根，后根

   ​

2. 简单实现一个 HashMap

   ​

3. 简单实现一个阻塞队列



## 架构设计

1. 设计一个发号器，毫秒级不能重复并且可支持多业务

   方案一：
   如果没有并发，订单号只在一个线程内产生，那么由于程序是顺序执行的，不同订单的生成时间戳正常不同，因此用时间戳+随机数（或自增数）就可以区分各个订单。
   如果存在并发，且订单号是由一个进程中的多个线程产生的，那么只要把线程ID添加到序列号中就可以保证订单号唯一。
   如果存在并发，且订单号是由同一台主机中的多个进程产生的，那么只要把进程ID添加到序列号中就可以保证订单号唯一。
   如果存在并发，且订单号是由不同台主机产生的，那么MAC地址、IP地址或CPU序列号等能够区分主机的号码添加到序列号中就可以保证订单号唯一。

   ​

   方案二：
   时间戳+用户ID+几个随机数+乐观锁。

   ​

   方案三：
   用redis的原子递增，做好高可用集群。

   ​

   方案四（非纯数字）：
   java自带uuid。

   **缺点**：性能比较差，并且 UUID 比较长，占用空间大，间接导致数据库性能下降，更重要的是，UUID 并不具有有序性，这导致 B+ 树索引在写的时候会有过多的随机写操作（连续的ID会产生部分顺序写）

   ​

   ​

   方案五：**snowflake算法**

   snowflake是twitter开源的分布式ID生成算法，其**核心思想为，**一个long型的ID：

   - 41bit作为毫秒数
   - 10bit作为机器编号
   - 12bit作为毫秒内序列号

    

   算法单机每秒内理论上最多可以生成1000*(2^12)，也就是400W的ID，完全能满足业务的需求。

   参考：[vesta-id-generator](https://gitee.com/robertleepeak/vesta-id-generator)

   ​

   **总之，思路如下：**

   ***思路一：基于数据库生成***

   标识的生成方法有很多，有集中式的，分布式的；有后端的，前端的，当然还有人工的。 并没有一种通用的生成方法来适应各种应用场景。

   人工生成的确是一种方式，比如电子邮箱，微信ID，各种论坛的账号。在人想出标识的那一刻，是无法判断是否是唯一的，对这种生成方式的结果，显然在录入时都需要进行唯一性校验。所以，下面描述的几种生成方式，是在生成的那一刻就在一个命名空间内唯一，而不再需要进行唯一性校验。

   而基于数据库生成，一般包含以下几种：

   - MySQL(5.6) AUTO_INCREMENT 特性
   - Postgres(REL 9.6 Stable) SEQUENCE 特性
   - Oracle 数据库的 SEQUENCE 特性，有知道这一特性如何实现的，可以在 知乎 做一下解答。
   - Flickr Ticket Servers ，同时支持Sharding (文章发表于2010年2月8日，算法上线于2006年1月13日)。

   一般地，这种类型的生成方案，都可以设置其实初始值，以及增量步长。

   ​

   ***思路二：基于分布式集群协调器生成***

   在不使用数据库的情况下，通过一个后台服务对外提供高可用的、固定步长标识生成，则需要分布式的集群协调器进行。

   一般的，主流协调器有两类：

   - 以强一致性为目标的：ZooKeeper为代表
   - 以最终一致性为目标的：Consul为代表

   ZooKeeper的强一致性，是由Paxos协议保证的；Consul的最终一致性，是由Gossip协议保证的。

   在步长累计型生成算法中，最核心的就是保持一个累计值在整个集群中的「强一致性」。同时，这也

   会为唯一性标识的生成带来新的形成瓶颈。

   ​

   ***思路三：划分命名空间并行生成***

   似乎对于分布式的ID生成，以Twitter Snowflake为代表的， Flake 系列算法，经常可以被搜索引擎找到，但似乎MongoDB的ObjectId算法，更早地采用了这种思路。MongoDB 1.0 是在2009年8月27日 发布 的，并且0.9.10(2009年8月24日发布)和1.0两个版本没有差异。

   在StackOverflow上，最早的一个关于ObjectId的问题（http://stackoverflow.com/questions/2138687/whats-mongodb-hashs-size/2146071），时间是2010年1月27日。不知道Twitter的同学，是不是受此启发呢？

   https://docs.mongodb.com/manual/reference/method/ObjectId/

   ​

2. ​

3. ​

4. ​