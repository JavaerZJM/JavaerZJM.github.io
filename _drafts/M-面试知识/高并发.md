高并发的业务架构是:
前端:异步请求+资源静态化+cdn
后端:请求队列+轮询分发+负载均衡+共享缓存
数据层:redis缓存+数据分表+写队列
存储:raid阵列+热备
网络:dns轮询+DDOS攻击防护


##并发编程的原则和技巧
### 单一职责yuanze

分离并发相关代码和其他代码（并发相关代码有自己的开发、修改和调优生命周期）。

###限制数据作用域

两个线程修改共享对象的同一字段时可能会相互干扰，导致不可预期的行为，解决方案之一是构造临界区，但是必须限制临界区的数量。

###使用数据副本

数据副本是避免共享数据的好方法，复制出来的对象只是以只读的方式对待。Java 5的java.util.concurrent包中增加一个名为`CopyOnWriteArrayList`的类，它是List接口的子类型，所以你可以认为它是`ArrayList的线程安全的版本`，它使用了`写时复制的方式创建数据副本`进行操作来避免对共享数据并发访问而引发的问题。


###线程应尽可能独立

**让线程存在于自己的世界中，不与其他线程共享数据。**
有过Java Web开发经验的人都知道，`Servlet就是以单实例多线程的方式工作`，和每个请求相关的数据都是通过Servlet子类的service方法（或者是doGet或doPost方法）的参数传入的。只要Servlet中的代码只使用局部变量，Servlet就不会导致同步问题。Spring MVC的控制器也是这么做的，从请求中获得的对象都是以方法的参数传入而不是作为类的成员，很明显Struts 2的做法就正好相反，因此Struts 2中作为控制器的Action类都是每个请求对应一个实例。

##Java 5以前的并发编程

在Java 5以前，可以用`synchronized关键字`来实现锁的功能，它可以
1. 用在代码块和方法上，表示在执行整个代码块或方法之前线程必须取得合适的锁。
2. 对于类的非静态方法（成员方法）而言，这意味这要取得对象实例的锁，
3. 对于类的静态方法（类方法）而言，要取得类的Class对象的锁，
4. 对于同步代码块，程序员可以指定要取得的是那个对象的锁。 

不管是同步代码块还是同步方法，每次只有一个线程可以进入，如果其他线程试图进入（不管是同一同步块还是不同的同步块），JVM会将它们挂起（放入到等锁池中）。这种结构在并发理论中称为临界区（critical section）。

这里我们可以对Java中用synchronized实现同步和锁的功能做一个总结：

- 只能锁定对象，不能锁定基本数据类型
- 被锁定的对象数组中的单个对象不会被锁定
- 同步方法可以视为包含整个方法的synchronized(this) { … }代码块
- 静态同步方法会锁定它的Class对象
- 内部类的同步是独立于外部类的
- synchronized修饰符并不是方法签名的组成部分，所以不能出现在接口的方法声明中
- 非同步的方法不关心锁的状态，它们在同步方法运行时仍然可以得以运行
- synchronized实现的锁是可重入的锁。

在JVM内部，为了提高效率，同时运行的每个线程都会有它正在处理的数据的缓存副本，当我们使用synchronzied进行同步的时候，真正被同步的是在不同线程中表示被锁定对象的内存块（副本数据会保持和主内存的同步，现在知道为什么要用同步这个词汇了吧），简单的说就是在同步块或同步方法执行完后，对被锁定的对象做的任何修改要在释放锁之前写回到主内存中；在进入同步块得到锁之后，被锁定对象的数据是从主内存中读出来的，持有锁的线程的数据副本一定和主内存中的数据视图是同步的 。

在Java最初的版本中，就有一个叫`volatile的关键字`，它是一种简单的同步的处理机制，因为被volatile修饰的变量遵循以下规则：

- 变量的值在使用之前总会从主内存中再读取出来。
- 对变量值的修改总会在完成之后写回到主内存中。

使用volatile关键字可以在多线程环境下预防编译器不正确的优化假设（编译器可能会将在一个线程中值不会发生改变的变量优化成常量），但只有修改时不依赖当前状态（读取时的值）的变量才应该声明为volatile变量。 

##Java 5的并发编程
###原子类
Java 5中的java.util.concurrent包下面有一个atomic子包，其中有几个以Atomic打头的类，例如AtomicInteger和AtomicLong。它们利用了现代处理器的特性，可以用非阻塞的方式完成原子操作，代码如下所示：
```java
/**
 ID序列生成器
*/
public class IdGenerator {
    private final AtomicLong sequenceNumber = new AtomicLong(0);

    public long next() {
        return sequenceNumber.getAndIncrement(); 
    }
}
```

###显示锁
基于synchronized关键字的锁机制有以下问题：

>- 锁只有一种类型，而且对所有同步操作都是一样的作用
>- 锁只能在代码块或方法开始的地方获得，在结束的地方释放
>- 线程要么得到锁，要么阻塞，没有其他的可能性

Java 5对锁机制进行了重构，提供了显示的锁，这样可以在以下几个方面提升锁机制：

>- 可以添加不同类型的锁，例如读取锁和写入锁
>- 可以在一个方法中加锁，在另一个方法中解锁
>- 可以使用tryLock方式尝试获得锁，如果得不到锁可以等待、回退或者干点别的事情，当然也可以在超时之后放弃操作

显示的锁都实现了java.util.concurrent.Lock接口，主要有两个实现类：

>- ReentrantLock - 比synchronized稍微灵活一些的重入锁
>- ReentrantReadWriteLock - 在读操作很多写操作很少时性能更好的一种重入锁

解锁的方法unlock的调用最好能够在finally块中，因为这里是释放外部资源最好的地方，当然也是释放锁的最佳位置，因为不管正常异常可能都要释放掉锁来给其他线程以运行的机会。

###CountDownLatch


###ConcurrentHashMap


###CopyOnWriteArrayList


###Queue



>参考：[并发编程网](http://ifeve.com/java-multi-threading-concurrency-interview-questions-with-answers/)
https://www.cnblogs.com/heartstage/p/3415584.html
https://segmentfault.com/a/1190000012182774
https://segmentfault.com/a/1190000011045115
[骆昊的技术专栏](http://blog.csdn.net/jackfrued/article/details/44499227)
