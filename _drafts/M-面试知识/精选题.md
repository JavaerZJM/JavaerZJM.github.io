**1.HTTP请求的GET方法与POST方法的区别**

根据RFC7231的定义，HTTP请求方法是用来表示客户端发送该请求的目的以及当请求成功时客户端期望从服务器获取的结果。 HTTP请求方法有如下特性：`安全性`、`幂等性`与`可缓存性`。
- **安全性：**指的是客户端向服务端的资源发起的请求如果使用了安全的方法，就不应该引起服务端任何的状态变化，如果一个方法的语义在本质上是只读的，那么这个方法就是安全的。
- **幂等性:**指的是同一个请求方法执行多次和仅执行一次的效果完全相同，引入幂等主要是为了处理同一个请求重复发送的情况，比如在请求响应前失去连接，如果方法是幂等的，就可以放心地重发一次请求。
- **可缓存性:**顾名思义就是一个方法的响应内容是否可以被缓存。

GET方法用于用户向服务器请求特定的资源，因此没有请求体，是安全、幂等、可缓存的。POST方法的语义是向服务器发送数据，可以有请求体，它不是安全的，因为其可能引起服务器状态变化，也不是幂等的，所以重复发送请求会产生不同的效果，它一般是不可缓存的，除非在响应体中包含了“新鲜度”信息。

关于HTTP缓存，可以阅读沉思君之前的文章《[详解HTTP缓存](http://mp.weixin.qq.com/s?__biz=MzAxNjM2MTk0Ng==&mid=2247483678&idx=1&sn=f18ab926dbea6491c9506432134a6026&chksm=9bf4b1abac8338bd6c6d520ff2d00ada8ce3c98f307f5fa0d04b9b8d5eb5b545270d25600b69&scene=21#wechat_redirect)》进行深入学习。

**2\. Session与Cookie的区别**

由于HTTP是无状态的，在HTTP通信过程中为了实现状态保持，可以使用Session机制。Session存储了用户或客户端的状态信息，其通常是保存在服务端的内存中，并会设置一个过期时间。那么服务端如何确定哪个用户或客户端对应哪个Session呢？很简单，只要客户端发送HTTP请求时带上一个SessionId过来就行了。这个SessionId一般存储在Cookie中，而Cookie是存储在浏览器或客户端的，通常也会设置一个过期时间，还会指定某个Cookie对应哪个域名，当浏览器向该域名下的服务器发送HTTP请求时，会自动带上未过期的Cookie，这样一来服务端就能从Cookie中拿到SessionId，将该次HTTP请求与服务端保存的Session关联起来，从而实现状态保持。

关于HTTP的状态保持，可以阅读沉思君之前的文章《[谈谈HTTP状态保持](http://mp.weixin.qq.com/s?__biz=MzAxNjM2MTk0Ng==&mid=2247483690&idx=1&sn=2893ac02e7b7ac4423884e5a05a985de&chksm=9bf4b19fac833889e61c29afbf130461b70c82ba01384b14bf485069fd619859ac2b5c80b80a&scene=21#wechat_redirect)》进行深入学习。

**问题延伸**：如果浏览器禁用了Cookie，如何实现Session状态保持？

**3.Session分布式处理**

在上一题中说到，Session信息默认是存储在服务器内存中的，而在生产环境中，我们通常会部署多台服务器，客户端发送的HTTP请求一般要先通过负载均衡器才能到达具体的后台服务器，这就会导致每次HTTP请求可能落到不同的服务器上，因此就会出现Session在分布式环境下失效的问题。Session分布式处理一般有如下几种思路：

1.  将每个相同客户端都路由到同一台服务器。比如通过计算ip的Hash值，将来自相同ip的HTTP请求都路由到同一台服务器上，这样一来从相同ip发起的HTTP请求都能到达同一台服务器，也就每次都能获取到Session信息了。

2.  Session同步。这种方式的Session信息还是保存在服务端内存，但是每个服务器之间需要进行Session同步，这样一来每台服务器上都有所有用户的Session信息，也就不会出现Session失效的问题了。

3.  Session集中存储。这种方式指的是不将Session存储在服务器内存，而是进行集中存储，比如存储在分布式缓存Redis中，这样的话就可以实现Session共享，也能够解决Session失效问题。

**问题延伸**：上述三种Session分布式处理方案各有什么优缺点？

**4.ThreadLocal原理分析**

ThreadLocal是一个保存线程本地化变量的容器，当在多线程环境下使用ThreadLocal维护变量时，其会为每个线程分配一个独立的变量副本，这样一来每个线程都只能对其变量副本进行读写而不会影响到其他线程的变量副本，从而保证了线程安全。

ThredLocal的实现是这样的，首先在每个线程对象内部保存了一个map，这个map的key是ThreadLocal实例，value是ThreadLocal中要保存的值，每当使用ThreadLocal对变量副本进行set的时候，首先会从当前线程对象内部拿到相应的map，然后将ThreadLocal实例自身作为key，要保存的值作为value，put进map中，这样一来就实现了每个线程保存了独立的变量副本，它们之间互不影响。

**问题延伸**：聊聊ThreadLocal的内存泄露问题。

